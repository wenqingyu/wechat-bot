"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * wechaty: Wechat for Bot. and for human who talk to bot/robot
 *
 * Licenst: ISC
 * https://github.com/zixia/wechaty
 *
 */
const moment = require("moment");
const config_1 = require("./config");
const message_1 = require("./message");
const util_lib_1 = require("./util-lib");
class MediaMessage extends message_1.Message {
    constructor(rawObj) {
        super(rawObj);
        // FIXME: decoupling needed
        this.bridge = config_1.Config.puppetInstance()
            .bridge;
    }
    ready() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly('MediaMessage', 'ready()');
            try {
                yield _super("ready").call(this);
                let url = null;
                switch (this.type()) {
                    case 47 /* EMOTICON */:
                        url = yield this.bridge.getMsgEmoticon(this.id);
                        break;
                    case 3 /* IMAGE */:
                        url = yield this.bridge.getMsgImg(this.id);
                        break;
                    case 43 /* VIDEO */:
                    case 62 /* MICROVIDEO */:
                        url = yield this.bridge.getMsgVideo(this.id);
                        break;
                    case 34 /* VOICE */:
                        url = yield this.bridge.getMsgVoice(this.id);
                        break;
                    case 49 /* APP */:
                        if (!this.rawObj) {
                            throw new Error('no rawObj');
                        }
                        switch (this.typeApp()) {
                            case 6 /* ATTACH */:
                                if (!this.rawObj.MMAppMsgDownloadUrl) {
                                    throw new Error('no MMAppMsgDownloadUrl');
                                }
                                // had set in Message
                                // url = this.rawObj.MMAppMsgDownloadUrl
                                break;
                            case 5 /* URL */:
                            case 100001 /* READER_TYPE */:
                                if (!this.rawObj.Url) {
                                    throw new Error('no Url');
                                }
                                // had set in Message
                                // url = this.rawObj.Url
                                break;
                            default:
                                const e = new Error('ready() unsupported typeApp(): ' + this.typeApp());
                                config_1.log.warn('MediaMessage', e.message);
                                this.dumpRaw();
                                throw e;
                        }
                        break;
                    case 1 /* TEXT */:
                        if (this.typeSub() === 48 /* LOCATION */) {
                            url = yield this.bridge.getMsgPublicLinkImg(this.id);
                        }
                        break;
                    default:
                        throw new Error('not support message type for MediaMessage');
                }
                if (!url) {
                    if (!this.obj.url) {
                        throw new Error('no obj.url');
                    }
                    url = this.obj.url;
                }
                this.obj.url = url;
            }
            catch (e) {
                config_1.log.warn('MediaMessage', 'ready() exception: %s', e.message);
                throw e;
            }
        });
    }
    ext() {
        switch (this.type()) {
            case 47 /* EMOTICON */:
                return 'gif';
            case 3 /* IMAGE */:
                return 'jpg';
            case 43 /* VIDEO */:
            case 62 /* MICROVIDEO */:
                return 'mp4';
            case 34 /* VOICE */:
                return 'mp3';
            case 49 /* APP */:
                switch (this.typeApp()) {
                    case 5 /* URL */:
                        return 'url'; // XXX
                }
                break;
            case 1 /* TEXT */:
                if (this.typeSub() === 48 /* LOCATION */) {
                    return 'jpg';
                }
                break;
        }
        throw new Error('not support type: ' + this.type());
    }
    filename() {
        if (!this.rawObj) {
            throw new Error('no rawObj');
        }
        const objFileName = this.rawObj.FileName || this.rawObj.MediaId || this.rawObj.MsgId;
        let filename = moment().format('YYYY-MM-DD HH:mm:ss')
            + ' #' + this._counter
            + ' ' + this.getSenderString()
            + ' ' + objFileName;
        filename = filename.replace(/ /g, '_');
        const re = /\.[a-z0-9]{1,7}$/i;
        if (!re.test(filename)) {
            const ext = this.rawObj.MMAppMsgFileExt || this.ext();
            filename += '.' + ext;
        }
        return filename;
    }
    // private getMsgImg(id: string): Promise<string> {
    //   return this.bridge.getMsgImg(id)
    //   .catch(e => {
    //     log.warn('MediaMessage', 'getMsgImg(%d) exception: %s', id, e.message)
    //     throw e
    //   })
    // }
    readyStream() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.ready();
                // FIXME: decoupling needed
                const cookies = yield config_1.Config.puppetInstance().browser.readCookie();
                if (!this.obj.url) {
                    throw new Error('no url');
                }
                return util_lib_1.UtilLib.urlStream(this.obj.url, cookies);
            }
            catch (e) {
                config_1.log.warn('MediaMessage', 'stream() exception: %s', e.stack);
                throw e;
            }
        });
    }
}
exports.MediaMessage = MediaMessage;
//# sourceMappingURL=message-media.js.map