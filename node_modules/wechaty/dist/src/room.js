"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const config_1 = require("./config");
const contact_1 = require("./contact");
const message_1 = require("./message");
const util_lib_1 = require("./util-lib");
/**
 *
 * wechaty: Wechat for Bot. and for human who talk to bot/robot
 *
 * Licenst: ISC
 * https://github.com/zixia/wechaty
 *
 * Add/Del/Topic: https://github.com/wechaty/wechaty/issues/32
 *
 */
class Room extends events_1.EventEmitter {
    constructor(id) {
        super();
        this.id = id;
        config_1.log.silly('Room', `constructor(${id})`);
    }
    toString() { return this.id; }
    toStringEx() { return `Room(${this.obj && this.obj.topic}[${this.id}])`; }
    isReady() {
        return !!(this.obj && this.obj.memberList && this.obj.memberList.length);
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isReady()) {
                this.dirtyObj = this.obj;
            }
            this.obj = null;
            yield this.ready();
            return;
        });
    }
    readyAllMembers(memberList) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let member of memberList) {
                let contact = contact_1.Contact.load(member.UserName);
                yield contact.ready();
            }
            return;
        });
    }
    ready(contactGetter) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly('Room', 'ready(%s)', contactGetter ? contactGetter.constructor.name : '');
            if (!this.id) {
                const e = new Error('ready() on a un-inited Room');
                config_1.log.warn('Room', e.message);
                throw e;
            }
            else if (this.isReady()) {
                return;
            }
            else if (this.obj && this.obj.id) {
                config_1.log.warn('Room', 'ready() has obj.id but memberList empty in room %s. reloading', this.obj.topic);
            }
            if (!contactGetter) {
                contactGetter = config_1.Config.puppetInstance()
                    .getContact.bind(config_1.Config.puppetInstance());
            }
            if (!contactGetter) {
                throw new Error('no contactGetter');
            }
            try {
                const data = yield contactGetter(this.id);
                config_1.log.silly('Room', `contactGetter(${this.id}) resolved`);
                this.rawObj = data;
                yield this.readyAllMembers(this.rawObj.MemberList || []);
                this.obj = this.parse(this.rawObj);
                if (!this.obj) {
                    throw new Error('no this.obj set after contactGetter');
                }
                yield Promise.all(this.obj.memberList.map(c => c.ready(contactGetter)));
                return;
            }
            catch (e) {
                config_1.log.error('Room', 'contactGetter(%s) exception: %s', this.id, e.message);
                throw e;
            }
        });
    }
    on(event, listener) {
        config_1.log.verbose('Room', 'on(%s, %s)', event, typeof listener);
        // const thisWithSay = {
        //   say: (content: string) => {
        //     return Config.puppetInstance()
        //                   .say(content)
        //   }
        // }
        // super.on(event, function() {
        //   return listener.apply(thisWithSay, arguments)
        // })
        super.on(event, listener); // Room is `Sayable`
        return this;
    }
    say(content, replyTo) {
        config_1.log.verbose('Room', 'say(%s, %s)', content, Array.isArray(replyTo)
            ? replyTo.map(c => c.name()).join(', ')
            : replyTo ? replyTo.name() : '');
        const m = new message_1.Message();
        m.room(this);
        const replyToList = [].concat(replyTo || []);
        if (replyToList.length > 0) {
            const mentionList = replyToList.map(c => '@' + c.name()).join(' ');
            m.content(mentionList + ' ' + content);
        }
        else {
            m.content(content);
        }
        // m.to(replyToList[0])
        return config_1.Config.puppetInstance()
            .send(m);
    }
    get(prop) { return (this.obj && this.obj[prop]) || (this.dirtyObj && this.dirtyObj[prop]); }
    parse(rawObj) {
        if (!rawObj) {
            config_1.log.warn('Room', 'parse() on a empty rawObj?');
            return null;
        }
        const memberList = (rawObj.MemberList || [])
            .map(m => contact_1.Contact.load(m.UserName));
        const nameMap = this.parseMap('name', rawObj.MemberList);
        const aliasMap = this.parseMap('alias', rawObj.MemberList);
        return {
            id: rawObj.UserName,
            encryId: rawObj.EncryChatRoomId,
            topic: rawObj.NickName,
            ownerUin: rawObj.OwnerUin,
            memberList,
            nameMap,
            aliasMap,
        };
    }
    parseMap(parseContent, memberList) {
        const mapList = new Map();
        if (memberList && memberList.map) {
            memberList.forEach(member => {
                let tmpName;
                let contact = contact_1.Contact.load(member.UserName);
                switch (parseContent) {
                    case 'name':
                        tmpName = contact.alias() || contact.name();
                        break;
                    case 'alias':
                        tmpName = member.DisplayName || contact.name();
                        break;
                    default:
                        throw new Error('parseMap failed, member not found');
                }
                /**
                 * ISSUE #64 emoji need to be striped
                 * ISSUE #104 never use remark name because sys group message will never use that
                 * @rui: Wrong for 'never use remark name because sys group message will never use that', see more in the latest comment in #104
                 * @rui: webwx's NickName here return contactAlias, if not set contactAlias, return name
                 * @rui: 2017-7-2 webwx's NickName just ruturn name, no contactAlias
                 */
                mapList[member.UserName] = util_lib_1.UtilLib.stripEmoji(tmpName);
            });
        }
        return mapList;
    }
    dumpRaw() {
        console.error('======= dump raw Room =======');
        Object.keys(this.rawObj).forEach(k => console.error(`${k}: ${this.rawObj[k]}`));
    }
    dump() {
        console.error('======= dump Room =======');
        Object.keys(this.obj).forEach(k => console.error(`${k}: ${this.obj && this.obj[k]}`));
    }
    add(contact) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('Room', 'add(%s)', contact);
            if (!contact) {
                throw new Error('contact not found');
            }
            const n = config_1.Config.puppetInstance()
                .roomAdd(this, contact);
            return n;
        });
    }
    del(contact) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('Room', 'del(%s)', contact.name());
            if (!contact) {
                throw new Error('contact not found');
            }
            const n = yield config_1.Config.puppetInstance()
                .roomDel(this, contact)
                .then(_ => this.delLocal(contact));
            return n;
        });
    }
    delLocal(contact) {
        config_1.log.verbose('Room', 'delLocal(%s)', contact);
        const memberList = this.obj && this.obj.memberList;
        if (!memberList || memberList.length === 0) {
            return 0; // already in refreshing
        }
        let i;
        for (i = 0; i < memberList.length; i++) {
            if (memberList[i].id === contact.id) {
                break;
            }
        }
        if (i < memberList.length) {
            memberList.splice(i, 1);
            return 1;
        }
        return 0;
    }
    quit() {
        throw new Error('wx web not implement yet');
        // WechatyBro.glue.chatroomFactory.quit("@@1c066dfcab4ef467cd0a8da8bec90880035aa46526c44f504a83172a9086a5f7"
    }
    topic(newTopic) {
        if (!this.isReady()) {
            config_1.log.warn('Room', 'topic() room not ready');
        }
        if (newTopic) {
            config_1.log.verbose('Room', 'topic(%s)', newTopic);
            config_1.Config.puppetInstance().roomTopic(this, newTopic)
                .catch(e => {
                config_1.log.warn('Room', 'topic(newTopic=%s) exception: %s', newTopic, e && e.message || e);
            });
            if (!this.obj) {
                this.obj = {};
            }
            Object.assign(this.obj, { topic: newTopic });
            return;
        }
        return util_lib_1.UtilLib.plainText(this.obj ? this.obj.topic : '');
    }
    /**
     * should be deprecated
     * @deprecated
     */
    nick(contact) {
        config_1.log.warn('Room', 'nick(Contact) DEPRECATED, use alias(Contact) instead.');
        return this.alias(contact);
    }
    alias(contact) {
        if (!this.obj || !this.obj.aliasMap) {
            return null;
        }
        return this.obj.aliasMap[contact.id] || null;
    }
    has(contact) {
        if (!this.obj || !this.obj.memberList) {
            return false;
        }
        return this.obj.memberList
            .filter(c => c.id === contact.id)
            .length > 0;
    }
    owner() {
        const ownerUin = this.obj && this.obj.ownerUin;
        let memberList = (this.obj && this.obj.memberList) || [];
        let user = config_1.Config.puppetInstance()
            .user;
        if (user && user.get('uin') === ownerUin) {
            return user;
        }
        memberList = memberList.filter(m => m.get('uin') === ownerUin);
        if (memberList.length > 0) {
            return memberList[0];
        }
        if (this.rawObj.ChatRoomOwner) {
            return contact_1.Contact.load(this.rawObj.ChatRoomOwner);
        }
        return null;
    }
    member(queryArg) {
        if (typeof queryArg === 'string') {
            return this.member({ name: queryArg });
        }
        config_1.log.silly('Room', 'member({ %s })', Object.keys(queryArg)
            .map(k => `${k}: ${queryArg[k]}`)
            .join(', '));
        if (Object.keys(queryArg).length !== 1) {
            throw new Error('Room member find queryArg only support one key. multi key support is not availble now.');
        }
        if (!this.obj || !this.obj.memberList) {
            config_1.log.warn('Room', 'member() not ready');
            return null;
        }
        let filterKey = Object.keys(queryArg)[0];
        /**
         * ISSUE #64 emoji need to be striped
         */
        let filterValue = util_lib_1.UtilLib.stripEmoji(queryArg[filterKey]);
        const keyMap = {
            name: 'nameMap',
            alias: 'aliasMap',
        };
        filterKey = keyMap[filterKey];
        if (!filterKey) {
            throw new Error('unsupport filter key');
        }
        if (!filterValue) {
            throw new Error('filterValue not found');
        }
        const filterMap = this.obj[filterKey];
        const idList = Object.keys(filterMap)
            .filter(k => filterMap[k] === filterValue);
        config_1.log.silly('Room', 'member() check %s from %s: %s', filterValue, filterKey, JSON.stringify(filterMap));
        if (idList.length) {
            return contact_1.Contact.load(idList[0]);
        }
        else {
            return null;
        }
    }
    memberList() {
        config_1.log.verbose('Room', 'memberList');
        if (!this.obj || !this.obj.memberList || this.obj.memberList.length < 1) {
            config_1.log.warn('Room', 'memberList() not ready');
            return [];
        }
        return this.obj.memberList;
    }
    static create(contactList, topic) {
        config_1.log.verbose('Room', 'create(%s, %s)', contactList.join(','), topic);
        if (!contactList || !Array.isArray(contactList)) {
            throw new Error('contactList not found');
        }
        return config_1.Config.puppetInstance()
            .roomCreate(contactList, topic)
            .catch(e => {
            config_1.log.error('Room', 'create() exception: %s', e && e.stack || e.message || e);
            throw e;
        });
    }
    static findAll(query) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!query) {
                query = { topic: /.*/ };
            }
            config_1.log.verbose('Room', 'findAll({ topic: %s })', query.topic);
            let topicFilter = query.topic;
            if (!topicFilter) {
                throw new Error('topicFilter not found');
            }
            let filterFunction;
            if (topicFilter instanceof RegExp) {
                filterFunction = `(function (c) { return ${topicFilter.toString()}.test(c) })`;
            }
            else if (typeof topicFilter === 'string') {
                topicFilter = topicFilter.replace(/'/g, '\\\'');
                filterFunction = `(function (c) { return c === '${topicFilter}' })`;
            }
            else {
                throw new Error('unsupport topic type');
            }
            return config_1.Config.puppetInstance()
                .roomFind(filterFunction)
                .catch(e => {
                config_1.log.verbose('Room', 'findAll() rejected: %s', e.message);
                return []; // fail safe
            });
        });
    }
    static find(query) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('Room', 'find({ topic: %s })', query.topic);
            const roomList = yield Room.findAll(query);
            if (!roomList || roomList.length < 1) {
                throw new Error('no room found');
            }
            const room = roomList[0];
            yield room.ready();
            return room;
        });
    }
    /**
     * @todo document me
     */
    static load(id) {
        if (!id) {
            throw new Error('Room.load() no id');
        }
        if (id in Room.pool) {
            return Room.pool[id];
        }
        return Room.pool[id] = new Room(id);
    }
}
Room.pool = new Map();
exports.Room = Room;
//# sourceMappingURL=room.js.map