"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * Wechaty: * * Wechaty - Wechat for Bot. Connecting ChatBots
 *
 * Licenst: ISC
 * https://github.com/wechaty/wechaty
 *
 */
const config_1 = require("./config");
const contact_1 = require("./contact");
const room_1 = require("./room");
const util_lib_1 = require("./util-lib");
class Message {
    constructor(rawObj) {
        this.rawObj = rawObj;
        this.obj = {};
        this._counter = Message.counter++;
        config_1.log.silly('Message', 'constructor() SN:%d', this._counter);
        if (typeof rawObj === 'string') {
            this.rawObj = JSON.parse(rawObj);
        }
        this.rawObj = rawObj = rawObj || {};
        this.obj = this.parse(rawObj);
        this.id = this.obj.id;
    }
    readyStream() {
        throw Error('abstract method');
    }
    filename() {
        throw Error('not a media message');
    }
    // Transform rawObj to local m
    parse(rawObj) {
        const obj = {
            id: rawObj.MsgId,
            type: rawObj.MsgType,
            from: rawObj.MMActualSender,
            to: rawObj.ToUserName,
            content: rawObj.MMActualContent,
            status: rawObj.Status,
            digest: rawObj.MMDigest,
            date: rawObj.MMDisplayTime,
            url: rawObj.Url || rawObj.MMAppMsgDownloadUrl || rawObj.MMLocationUrl,
        };
        // FIXME: has ther any better method to know the room ID?
        if (rawObj.MMIsChatRoom) {
            if (/^@@/.test(rawObj.FromUserName)) {
                obj.room = rawObj.FromUserName; // MMPeerUserName always eq FromUserName ?
            }
            else if (/^@@/.test(rawObj.ToUserName)) {
                obj.room = rawObj.ToUserName;
            }
            else {
                config_1.log.error('Message', 'parse found a room message, but neither FromUserName nor ToUserName is a room(/^@@/)');
                // obj.room = undefined // bug compatible
            }
            if (obj.to && /^@@/.test(obj.to)) {
                obj.to = undefined;
            }
        }
        return obj;
    }
    toString() {
        return util_lib_1.UtilLib.plainText(this.obj.content);
    }
    toStringDigest() {
        const text = util_lib_1.UtilLib.digestEmoji(this.obj.digest);
        return '{' + this.typeEx() + '}' + text;
    }
    toStringEx() {
        let s = `${this.constructor.name}#${this._counter}`;
        s += '(' + this.getSenderString();
        s += ':' + this.getContentString() + ')';
        return s;
    }
    getSenderString() {
        const fromName = contact_1.Contact.load(this.obj.from).name();
        const roomTopic = this.obj.room
            ? (':' + room_1.Room.load(this.obj.room).topic())
            : '';
        return `<${fromName}${roomTopic}>`;
    }
    getContentString() {
        let content = util_lib_1.UtilLib.plainText(this.obj.content);
        if (content.length > 20) {
            content = content.substring(0, 17) + '...';
        }
        return '{' + this.type() + '}' + content;
    }
    from(contact) {
        if (contact) {
            if (contact instanceof contact_1.Contact) {
                this.obj.from = contact.id;
            }
            else if (typeof contact === 'string') {
                this.obj.from = contact;
            }
            else {
                throw new Error('unsupport from param: ' + typeof contact);
            }
            return;
        }
        const loadedContact = contact_1.Contact.load(this.obj.from);
        if (!loadedContact) {
            throw new Error('no from');
        }
        return loadedContact;
    }
    to(contact) {
        if (contact) {
            if (contact instanceof contact_1.Contact) {
                this.obj.to = contact.id;
            }
            else if (typeof contact === 'string') {
                this.obj.to = contact;
            }
            else {
                throw new Error('unsupport to param ' + typeof contact);
            }
            return;
        }
        // no parameter
        if (!this.obj.to) {
            return null;
        }
        return contact_1.Contact.load(this.obj.to);
    }
    room(room) {
        if (room) {
            if (room instanceof room_1.Room) {
                this.obj.room = room.id;
            }
            else if (typeof room === 'string') {
                this.obj.room = room;
            }
            else {
                throw new Error('unsupport room param ' + typeof room);
            }
            return;
        }
        if (this.obj.room) {
            return room_1.Room.load(this.obj.room);
        }
        return null;
    }
    content(content) {
        if (content) {
            this.obj.content = content;
            return;
        }
        return this.obj.content;
    }
    type() {
        return this.obj.type;
    }
    typeSub() {
        if (!this.rawObj) {
            throw new Error('no rawObj');
        }
        return this.rawObj.SubMsgType;
    }
    typeApp() {
        if (!this.rawObj) {
            throw new Error('no rawObj');
        }
        return this.rawObj.AppMsgType;
    }
    typeEx() { return Message.TYPE[this.obj.type]; }
    count() { return this._counter; }
    self() {
        const userId = config_1.Config.puppetInstance()
            .userId;
        const fromId = this.obj.from;
        if (!userId || !fromId) {
            throw new Error('no user or no from');
        }
        return fromId === userId;
    }
    // public ready() {
    //   log.warn('Message', 'ready() DEPRECATED. use load() instead.')
    //   return this.ready()
    // }
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.silly('Message', 'ready()');
            try {
                const from = contact_1.Contact.load(this.obj.from);
                yield from.ready(); // Contact from
                if (this.obj.to) {
                    const to = contact_1.Contact.load(this.obj.to);
                    yield to.ready();
                }
                if (this.obj.room) {
                    const room = room_1.Room.load(this.obj.room);
                    yield room.ready(); // Room member list
                }
            }
            catch (e) {
                config_1.log.error('Message', 'ready() exception: %s', e.stack);
                // console.log(e)
                // this.dump()
                // this.dumpRaw()
                throw e;
            }
        });
    }
    /**
     * @deprecated
     */
    get(prop) {
        config_1.log.warn('Message', 'DEPRECATED get() at %s', new Error('stack').stack);
        if (!prop || !(prop in this.obj)) {
            const s = '[' + Object.keys(this.obj).join(',') + ']';
            throw new Error(`Message.get(${prop}) must be in: ${s}`);
        }
        return this.obj[prop];
    }
    /**
     * @deprecated
     */
    set(prop, value) {
        config_1.log.warn('Message', 'DEPRECATED set() at %s', new Error('stack').stack);
        if (typeof value !== 'string') {
            throw new Error('value must be string, we got: ' + typeof value);
        }
        this.obj[prop] = value;
        return this;
    }
    dump() {
        console.error('======= dump message =======');
        Object.keys(this.obj).forEach(k => console.error(`${k}: ${this.obj[k]}`));
    }
    dumpRaw() {
        console.error('======= dump raw message =======');
        Object.keys(this.rawObj).forEach(k => console.error(`${k}: ${this.rawObj && this.rawObj[k]}`));
    }
    static find(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(new Message({ MsgId: '-1' }));
        });
    }
    static findAll(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve([
                new Message({ MsgId: '-2' }),
                new Message({ MsgId: '-3' }),
            ]);
        });
    }
    static initType() {
        Object.keys(Message.TYPE).forEach(k => {
            const v = Message.TYPE[k];
            Message.TYPE[v] = k; // Message.Type[1] = 'TEXT'
        });
    }
    say(content, replyTo) {
        config_1.log.verbose('Message', 'say(%s, %s)', content, replyTo);
        const m = new Message();
        const room = this.room();
        if (room) {
            m.room(room);
        }
        if (!replyTo) {
            m.to(this.from());
            m.content(content);
        }
        else if (this.room()) {
            let mentionList;
            if (Array.isArray(replyTo)) {
                m.to(replyTo[0]);
                mentionList = replyTo.map(c => '@' + c.name()).join(' ');
            }
            else {
                m.to(replyTo);
                mentionList = '@' + replyTo.name();
            }
            m.content(mentionList + ' ' + content);
        }
        return config_1.Config.puppetInstance()
            .send(m);
    }
}
Message.counter = 0;
Message.TYPE = {
    TEXT: 1,
    IMAGE: 3,
    VOICE: 34,
    VERIFYMSG: 37,
    POSSIBLEFRIEND_MSG: 40,
    SHARECARD: 42,
    VIDEO: 43,
    EMOTICON: 47,
    LOCATION: 48,
    APP: 49,
    VOIPMSG: 50,
    STATUSNOTIFY: 51,
    VOIPNOTIFY: 52,
    VOIPINVITE: 53,
    MICROVIDEO: 62,
    SYSNOTICE: 9999,
    SYS: 10000,
    RECALLED: 10002,
};
exports.Message = Message;
Message.initType();
__export(require("./message-media"));
/*
 * join room in mac client: https://support.weixin.qq.com/cgi-bin/
 * mmsupport-bin/addchatroombyinvite
 * ?ticket=AUbv%2B4GQA1Oo65ozlIqRNw%3D%3D&exportkey=AS9GWEg4L82fl3Y8e2OeDbA%3D
 * &lang=en&pass_ticket=T6dAZXE27Y6R29%2FFppQPqaBlNwZzw9DAN5RJzzzqeBA%3D
 * &wechat_real_lang=en
 */
//# sourceMappingURL=message.js.map