"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * Wechaty: Wechat for Bot. and for human who talk to bot/robot
 *
 * Class StateMonitor
 * http://www.wechaty.io
 *
 * Licenst: ISC
 * https://github.com/zixia/wechaty
 *
 * Helper Class for Manage State Change
 */
const config_1 = require("./config");
/**
 * A - State A
 * B - State B
 */
class StateMonitor {
    constructor(_client, initState) {
        this._client = _client;
        config_1.log.silly('StateMonitor', 'constructor(%s, %s)', _client, initState);
        this._target = initState;
        this._current = initState;
        this._stable = true;
    }
    /**
     * set/get target state
     */
    target(newState) {
        if (newState) {
            config_1.log.verbose('StateMonitor', '%s:target(%s) <- (%s)', this._client, newState, this._target);
            this._target = newState;
        }
        else {
            config_1.log.silly('StateMonitor', '%s:target() - %s', this._client, this._target);
        }
        return this._target;
    }
    /**
     * set/get current state
     * @param stable boolean  true for stable, false for inprocess
     */
    current(newState, stable = true) {
        if (newState) {
            config_1.log.verbose('StateMonitor', '%s:current(%s,%s) <- (%s,%s)', this._client, newState, stable, this._current, this._stable);
            /**
             * strict check current is equal to target
             */
            if (this._target !== newState) {
                config_1.log.warn('StateMonitor', '%s:current(%s,%s) current is different with target. call state.target(%s) first.', this._client, newState, stable, newState);
                const e = new Error('current not match target');
                config_1.log.verbose('StateMonitor', e.stack);
                throw e;
            }
            /**
             * warn for inprocess current state change twice, mostly like a logic bug outside
             */
            if (this._current === newState && this._stable === stable
                && stable === false) {
                config_1.log.warn('StateMonitor', '%s:current(%s,%s) called but there are already in the same state', this._client, newState, stable);
                const e = new Error('current unchange');
                config_1.log.verbose('StateMonitor', e.stack);
            }
            this._current = newState;
            this._stable = stable;
        }
        else {
            config_1.log.silly('StateMonitor', '%s:current() - %s', this._client, this._current);
        }
        return this._current;
    }
    /**
     * does the current state be stable(not inprocess)?
     */
    stable() {
        config_1.log.silly('StateMonitor', '%s:stable() is %s', this._client, this._stable);
        return this._stable;
    }
    /**
     * does the current state be inprocess(not stable)?
     */
    inprocess() {
        config_1.log.silly('StateMonitor', '%s:inprocess() %s', this._client, !this._stable);
        return !this._stable;
    }
    /**
     * get the client name
     */
    client() {
        return this._client;
    }
}
exports.StateMonitor = StateMonitor;
//# sourceMappingURL=state-monitor.js.map